# -*- coding: utf-8 -*-
"""(B1) Time Expanded Arc Based.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EwxFHUhqsP7n20CEyjMIwHs26LkADYkE
"""

import pyomo.environ as pyo
import pandas as pd
import numpy as np
import xlrd
import xlwt
import xlsxwriter
import xlwings as xw

# Sets
# all nodes
V = ['s', 'a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3', 't1', 't2', 't3', 't']
# nodes with source and sink removed
V_1 = ['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3', 't1', 't2', 't3']
# nodes in time period 1
V1 = []
# nodes in time period 2
V2 = []
# nodes in time period 3
V3 = []
# all arcs in network
A = [('s', 'a1'), ('a1', 'b1'), ('a1', 'c1'), ('b1', 'c1'), ('b1', 't1'), ('c1', 't1'),
    ('a1', 'a2'), ('b1', 'b2'), ('c1', 'c2'), ('t1', 't2'),
    ('a2', 'b2'), ('a2', 'c2'), ('b2', 'c2'), ('b2', 't2'), ('c2', 't2'),
    ('a2', 'a3'), ('b2', 'b3'), ('c2', 'c3'), ('t2', 't3'),
    ('a3', 'b3'), ('a3', 'c3'), ('b3', 'c3'), ('b3', 't3'), ('c3', 't3'),
    ('a3', 't'), ('b3', 't'), ('c3', 't'), ('t3', 't')]
# arcs where the nodes are the same but to the next time period. Ex: (b2, b3)
A_1 = [('a1', 'a2'), ('a2', 'a3'), ('b1', 'b2'), ('b2', 'b3'),
       ('c1', 'c2'), ('c2', 'c3'), ('a3', 't'), ('b3', 't'), ('c3', 't')]

# Parameters
# lower bound number of assets to recieve value on arc i,j
l = {('a1', 'a2'): 25,
     ('a2', 'a3'): 30,
     ('b1', 'b2'): 15,
     ('b2', 'b3'): 35,
     ('c1', 'c2'): 20,
     ('c2', 'c3'): 10,
     ('a3', 't'): 20,
     ('b3', 't'): 30,
     ('c3', 't'): 20}
# value of arc i,j
v = {('a1', 'a2'): 5,
     ('a2', 'a3'): 7,
     ('b1', 'b2'): 4,
     ('b2', 'b3'): 8,
     ('c1', 'c2'): 6,
     ('c2', 'c3'): 2,
     ('a3', 't'): 3,
     ('b3', 't'): 4,
     ('c3', 't'): 3}
# max capacity of assets on arc i,j
m = {('s', 'a1'): 35,
     ('a1', 'b1'): 35,
     ('a1', 'c1'): 40,
     ('b1', 'c1'): 40,
     ('b1', 't1'): 40,
     ('c1', 't1'): 40,
     ('a1', 'a2'): 35,
     ('b1', 'b2'): 40,
     ('c1', 'c2'): 45,
     ('t1', 't2'): 15,
     ('a2', 'b2'): 50,
     ('a2', 'c2'): 35,
     ('b2', 'c2'): 35,
     ('b2', 't2'): 50,
     ('c2', 't2'): 40,
     ('a2', 'a3'): 35,
     ('b2', 'b3'): 45,
     ('c2', 'c3'): 45,
     ('t2', 't3'): 45,
     ('a3', 'b3'): 50,
     ('a3', 'c3'): 50,
     ('b3', 'c3'): 50,
     ('b3', 't3'): 50,
     ('c3', 't3'): 50,
     ('a3', 't'): 50,
     ('b3', 't'): 50,
     ('c3', 't'): 50,
     ('t3', 't'): 50}
# cost to send one asset on arc i,j
c = {('s', 'a1'): 1,
     ('a1', 'b1'): 1,
     ('a1', 'c1'): 1,
     ('b1', 'c1'): 1,
     ('b1', 't1'): 1,
     ('c1', 't1'): 1,
     ('a1', 'a2'): 1,
     ('b1', 'b2'): 1,
     ('c1', 'c2'): 1,
     ('t1', 't2'): 1,
     ('a2', 'b2'): 1,
     ('a2', 'c2'): 1,
     ('b2', 'c2'): 1,
     ('b2', 't2'): 1,
     ('c2', 't2'): 1,
     ('a2', 'a3'): 1,
     ('b2', 'b3'): 1,
     ('c2', 'c3'): 1,
     ('t2', 't3'): 1,
     ('a3', 'b3'): 1,
     ('a3', 'c3'): 1,
     ('b3', 'c3'): 1,
     ('b3', 't3'): 1,
     ('c3', 't3'): 1,
     ('a3', 't'): 1,
     ('b3', 't'): 1,
     ('c3', 't'): 1,
     ('t3', 't'): 1}
# total number of assets
f = 50
# max budget
B = 500

# Model creation with all constraints, decision variables, and objective function
model = pyo.ConcreteModel()
# number of assets sent on arc i,j
model.x = pyo.Var(A,domain=pyo.NonNegativeReals)
# 1 if x[i,j] >= l[i,j] on arc i,j in A_1, 0 o.w.
model.z = pyo.Var(A_1,domain=pyo.Binary)


def obj_rule(model):
    return sum(model.z[i,j]*v[i,j] for (i,j) in A_1)
model.obj = pyo.Objective(rule = obj_rule, sense = pyo.maximize)

def flow_source_rule(model):
    return sum(model.x[i,j] for (i, j) in A if i == 's') == f
model.flow_source_constraint = pyo.Constraint(rule=flow_source_rule)

def flow_sink_rule(model):
    return sum(model.x[i,j] for (i,j) in A if j == 't') == f
model.flow_sink_constraint = pyo.Constraint(rule=flow_sink_rule)

def flow_balance_rule(model, i):
    return sum(model.x[i,j] for j in V if (i,j) in A) - sum(model.x[j,i] for j in V if (j,i) in A) == 0
model.flow_balance_constraint = pyo.Constraint(V_1, rule=flow_balance_rule)

def value_rule(model, i,j):
    return model.x[i,j] >= model.z[i,j]*l[i,j]
model.value_constraint = pyo.Constraint(A_1, rule=value_rule)

def capacity_rule(model, i,j):
    return model.x[i,j] <= m[i,j]
model.capacity_constraint = pyo.Constraint(A_1, rule=capacity_rule)

def budget_rule(model):
    return sum(model.x[i,j]*c[i,j] for (i,j) in A) <= B
model.budget_constraint = pyo.Constraint(rule=budget_rule)

solver_result = pyo.SolverFactory('gurobi').solve(model)

# Prints optimum solution to model
def print_sol_here(model):
    # Check if the model solved to optimality before printing solution
    solve_status = solver_result.solver.termination_condition
    if (solve_status==pyo.TerminationCondition.optimal):
        for (i,j) in A:
            print(f'Flow on ({i},{j}):{model.x[i,j].value}')
        for (x,y) in A_1:
            if model.z[x,y].value == 1:
                print(f'Value from ({x},{y})')
    else:
        print(f'The solver status is {solve_status}')

print_sol_here(model)

# objective function value
sum(model.z[i,j].value*v[i,j] for (i,j) in A_1)

