# -*- coding: utf-8 -*-
"""(A5) Arcs and Time Periods Heuristic Approach Scaled Up Comparison to Normal (2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yKRBhRLaUwSSESjBa8YKKD40thDp9vl8
"""

import pyomo.environ as pyo
import pandas as pd
import numpy as np
import xlrd
import xlwt
import xlsxwriter
import xlwings as xw
import random
import time

# Sets
num_nodes = 15
num_time_periods = 20

# V all nodes
# V1 all nodes minus s
V = [0]
V1 = []
for i in range (1,num_nodes+1):
    V.append(i)
    V1.append(i)
# all arcs in network
A = []
for i in V:
    for j in V:
        if i < j:
            A.append((i,j))
# T all time periods
# T2 time periods for w variable creation
# T3 time periods for value constraint
T = []
T2 = [0]
for i in range(1,num_time_periods+1):
    T.append(i)
    T2.append(i)

# Parameters
# lower bound number of assets to recieve value at i during t
l = {}
for i in V1:
    for t in T:
        l[i,t] = random.randint(5,30)

# value of i during t
v = {}
for i in V1:
    for t in T:
        v[i,t] = random.randint(1,10)

# cost to send 1 asset from i to j during t
c = {}
for (i,j) in A:
    for t in T:
        c[(i,j,t)] = 1
# max capacity of assets on node i during t
m = {}
for i in V1:
    for t in T:
        m[(i,t)] = 30
# total amount of assets
f = 100
# number of assets at each node
b = {0: f}
for i in V1:
    b[i] = 0
# max budget
B = 1000000

def build_model(V, V1, A, first, last, b, l, v, c, m, B):

    #Create time periods
    T = []
    T2 = [first-1]
    for q in range(first,last+1):
        T.append(q)
        T2.append(q)

    # Model creation with all constraints, decision variables, and objective function
    model = pyo.ConcreteModel()
    # number of assets sent on arc i,j during t
    model.x = pyo.Var(A, T, domain=pyo.NonNegativeIntegers)
    # number of assets starting at i during t
    model.w = pyo.Var(V, T2, domain=pyo.NonNegativeIntegers)
    # 1 if x[i,j,t] >= l[i,t] at i during t, 0 o.w.
    model.z = pyo.Var(V, T, domain=pyo.Binary)


    def obj_rule(model):
        return sum(model.z[i,t]*v[i,t] for i in V1 for t in T)
    model.obj = pyo.Objective(rule = obj_rule, sense = pyo.maximize)

    def flow_balance_rule(model, i, t):
        return sum(model.x[j,i,t] for j in V if (j,i) in A) - sum(model.x[i,j,t] for j in V if (i,j) in A) + model.w[i,t-1] == model.w[i,t]
    model.flow_balance_constraint = pyo.Constraint(V, T, rule=flow_balance_rule)

    def value_rule(model, i, t):
        return model.w[i,t] >= l[i,t]*model.z[i,t]
    model.value_constraint = pyo.Constraint(V1, T, rule=value_rule)

    def capacity_rule(model, i, t):
        return model.w[i,t] <= m[i,t]
    model.capacity_constraint = pyo.Constraint(V1, T, rule=capacity_rule)

    def starting_value_rule(model, i):
        return model.w[i,first-1] == b[i]
    model.starting_value_constraint = pyo.Constraint(V, rule=starting_value_rule)

    def budget_rule(model):
        return sum(model.x[i,j,t]*c[i,j,t] for (i,j) in A for t in T) <= B
    model.budget_constraint = pyo.Constraint(rule=budget_rule)

    solver_result = pyo.SolverFactory('gurobi').solve(model)

    flows = {}
    total_value = 0
    for i in V:
        flows[i] = model.w[i,last].value
        #if i != 's' and i != 't':
         #   for t in T3:
          #      total_value += model.z[i,t].value*v[i,t]
    for t in T:
            for (i,j) in A:
                if model.x[i,j,t].value != 0:
                    print(f'Flow on ({i},{j}) during time {t}:{model.x[i,j,t].value}')
    for y in T:
        for x in V:
            if model.z[x,y].value == 1:
                print(f'Value on {x} during {y}')

    for q in T2:
        for z in V:
            print(f'Assets at {z}  {q}:{model.w[z,q].value}')

    total_value = sum(model.z[i,t].value*v[i,t] for i in V1 for t in T)
    return flows, total_value

steps = 4
step_size = int(num_time_periods/steps)
first = 1
last = first + step_size -1
total_objective = 0

while last <= num_time_periods:
    b, objective = build_model(V, V1, A, first, last, b, l, v, c, m, B)
    first += step_size
    last = first + step_size - 1
    print(objective)
    total_objective += objective
#     b = flows
print(total_objective)

# number of assets at each node
b = {0: f}
for i in V1:
    b[i] = 0
# Model creation with all constraints, decision variables, and objective function
model = pyo.ConcreteModel()
# number of assets sent on arc i,j during t
model.x = pyo.Var(A, T, domain=pyo.NonNegativeIntegers)
# number of assets starting at i during t
model.w = pyo.Var(V, T2, domain=pyo.NonNegativeIntegers)
# 1 if x[i,j,t] >= l[i,t] at i during t, 0 o.w.
model.z = pyo.Var(V, T, domain=pyo.Binary)


def obj_rule(model):
    return sum(model.z[i,t]*v[i,t] for i in V1 for t in T)
model.obj = pyo.Objective(rule = obj_rule, sense = pyo.maximize)

def flow_balance_rule(model, i, t):
    return sum(model.x[j,i,t] for j in V if (j,i) in A) - sum(model.x[i,j,t] for j in V if (i,j) in A) + model.w[i,t-1] == model.w[i,t]
model.flow_balance_constraint = pyo.Constraint(V, T, rule=flow_balance_rule)

def value_rule(model, i, t):
    return model.w[i,t] >= l[i,t]*model.z[i,t]
model.value_constraint = pyo.Constraint(V1, T,rule=value_rule)

def capacity_rule(model, i, t):
    return model.w[i,t] <= m[i,t]
model.capacity_constraint = pyo.Constraint(V1, T, rule=capacity_rule)

def starting_value_rule(model, i):
    return model.w[i,0] == b[i]
model.starting_value_constraint = pyo.Constraint(V, rule=starting_value_rule)

def budget_rule(model):
    return sum(model.x[i,j,t]*c[i,j,t] for (i,j) in A for t in T) <= B
model.budget_constraint = pyo.Constraint(rule=budget_rule)




solver = pyo.SolverFactory('gurobi')
solver.options['TimeLimit'] = 1

start_time = time.time()

solver_result = solver.solve(model)
#solver_result = solver.solve(model).write()

print("--- %s seconds ---" % (time.time() - start_time))



def print_sol_here(model):
    # Check if the model solved to optimality before printing solution
    solve_status = solver_result.solver.termination_condition
    if (solve_status==pyo.TerminationCondition.optimal):
        for t in T:
            for (i,j) in A:
                if model.x[i,j,t].value != 0:
                    print(f'Flow on ({i},{j}) during time {t}:{model.x[i,j,t].value}')
        for y in T:
            for x in V:
                if model.z[x,y].value == 1:
                    print(f'Value on {x} during {y}')
        for q in T2:
            for z in V:
                print(f'Assets at {z} at the end of {q}:{model.w[z,q].value}')
    else:
        print(f'The solver status is {solve_status}')
        for t in T:
            for (i,j) in A:
                if model.x[i,j,t].value != 0:
                    print(f'Flow on ({i},{j}) during time {t}:{model.x[i,j,t].value}')
        for y in T:
            for x in V:
                if model.z[x,y].value == 1:
                    print(f'Value on {x} during {y}')
        for q in T2:
            for z in V:
                print(f'Assets at {z} at the end of {q}:{model.w[z,q].value}')

print_sol_here(model)

#print(solver_result.upper_bound)


# objective function value
sum(model.z[i,t].value*v[i,t] for i in V1 for t in T)



b = {0: f}
for i in V1:
    b[i] = 0
# uses function on all time periods
build_model(V, V1, A, 1, num_time_periods, b, l, v, c, m, B)

"""15 nodes and 24 time periods time = 3 seconds
20 nodes and 24 time periods time = 5 seconds
"""

b = {0: f}
for i in V1:
    b[i] = 0

build_model(V, V1, A, 1, 12, b, l, v, c, m, B)

b = {0: 0,
    1: 17,
    2: 17,
    3: 5,
    4: 7,
    5: 0,
    6: 9,
    7: 30,
    8: 0,
    9: 0,
    10: 15}

build_model(V, V1, A, 1, 12, b, l, v, c, m, B)

def build_model3(V, V1, A, T, T2, b, l, v, c, m, B):
    # Model creation with all constraints, decision variables, and objective function
    model = pyo.ConcreteModel()
    # number of assets sent on arc i,j during t
    model.x = pyo.Var(A, T, domain=pyo.NonNegativeIntegers)
    # number of assets starting at i during t
    model.w = pyo.Var(V, T2, domain=pyo.NonNegativeIntegers)
    # 1 if x[i,j,t] >= l[i,t] at i during t, 0 o.w.
    model.z = pyo.Var(V, T, domain=pyo.Binary)


    def obj_rule(model):
        return sum(model.z[i,t]*v[i,t] for i in V1 for t in T)
    model.obj = pyo.Objective(rule = obj_rule, sense = pyo.maximize)

    def flow_balance_rule(model, i, t):
        return sum(model.x[j,i,t] for j in V if (j,i) in A) - sum(model.x[i,j,t] for j in V if (i,j) in A) + model.w[i,t-1] == model.w[i,t]
    model.flow_balance_constraint = pyo.Constraint(V, T, rule=flow_balance_rule)

    def value_rule(model, i, t):
        return model.w[i,t] >= l[i,t]*model.z[i,t]
    model.value_constraint = pyo.Constraint(V1, T,rule=value_rule)

    def capacity_rule(model, i, t):
        return model.w[i,t] <= m[i,t]
    model.capacity_constraint = pyo.Constraint(V1, T, rule=capacity_rule)

    def starting_value_rule(model, i):
        return model.w[i,0] == b[i]
    model.starting_value_constraint = pyo.Constraint(V, rule=starting_value_rule)

    def budget_rule(model):
        return sum(model.x[i,j,t]*c[i,j,t] for (i,j) in A for t in T) <= B
    model.budget_constraint = pyo.Constraint(rule=budget_rule)




    solver = pyo.SolverFactory('gurobi')
    solver.options['TimeLimit'] = 600

    start_time = time.time()

    solver_result = solver.solve(model).write()

    runtime = time.time() - start_time



    # objective function value
    total_value = sum(model.z[i,t].value*v[i,t] for i in V1 for t in T)

    return total_value, runtime

build_model3(V, V1, A, T, T2, b, l, v, c, m, B)

